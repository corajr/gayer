// Generated by BUCKLESCRIPT VERSION 4.0.3, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_Id from "bs-platform/lib/es6/belt_Id.js";
import * as Belt_Set from "bs-platform/lib/es6/belt_Set.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    var c$1 = Caml_obj.caml_compare(param[1], param$1[1]);
    if (c$1 !== 0) {
      return c$1;
    } else {
      var c$2 = Caml_obj.caml_compare(param[2], param$1[2]);
      if (c$2 !== 0) {
        return c$2;
      } else {
        return Caml_obj.caml_compare(param[3], param$1[3]);
      }
    }
  }
}

var EdgeComparator = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

var emptyEdgeSet = Belt_Set.make(EdgeComparator);

var emptyAudioGraph = /* record */[
  /* nodes */Belt_MapString.empty,
  /* edges */emptyEdgeSet,
  /* actuallyConnectedEdges */emptyEdgeSet
];

function addNode(param, graph) {
  return /* record */[
          /* nodes */Belt_MapString.set(graph[/* nodes */0], param[0], param[1]),
          /* edges */graph[/* edges */1],
          /* actuallyConnectedEdges */graph[/* actuallyConnectedEdges */2]
        ];
}

function removeAllEdgesInvolvingNode(key, graph) {
  return /* record */[
          /* nodes */graph[/* nodes */0],
          /* edges */Belt_Set.keep(graph[/* edges */1], (function (param) {
                  if (key !== param[0]) {
                    return key !== param[1];
                  } else {
                    return false;
                  }
                })),
          /* actuallyConnectedEdges */graph[/* actuallyConnectedEdges */2]
        ];
}

function removeNode(key, graph) {
  return /* record */[
          /* nodes */Belt_MapString.remove(graph[/* nodes */0], key),
          /* edges */graph[/* edges */1],
          /* actuallyConnectedEdges */graph[/* actuallyConnectedEdges */2]
        ];
}

function addEdge(edge, graph) {
  return /* record */[
          /* nodes */graph[/* nodes */0],
          /* edges */Belt_Set.add(graph[/* edges */1], edge),
          /* actuallyConnectedEdges */graph[/* actuallyConnectedEdges */2]
        ];
}

function removeEdge(edge, graph) {
  return /* record */[
          /* nodes */graph[/* nodes */0],
          /* edges */Belt_Set.remove(graph[/* edges */1], edge),
          /* actuallyConnectedEdges */graph[/* actuallyConnectedEdges */2]
        ];
}

function maybeApplyToGraph(f, param, graph) {
  var inputIndex = param[3];
  var outputIndex = param[2];
  var targetId = param[1];
  var sourceId = param[0];
  var maybeSource = Belt_MapString.get(graph[/* nodes */0], sourceId);
  var maybeTarget = Belt_MapString.get(graph[/* nodes */0], targetId);
  if (maybeSource !== undefined && maybeTarget !== undefined) {
    Curry._4(f, maybeSource, maybeTarget, outputIndex, inputIndex);
    return /* tuple */[
            sourceId,
            targetId,
            outputIndex,
            inputIndex
          ];
  }
  
}

function updateConnections(graph) {
  var edgesToConnect = Belt_Set.diff(graph[/* edges */1], graph[/* actuallyConnectedEdges */2]);
  var edgesToDisconnect = Belt_Set.diff(graph[/* actuallyConnectedEdges */2], graph[/* edges */1]);
  Belt_Set.forEach(edgesToDisconnect, (function (edge) {
          maybeApplyToGraph((function (prim, prim$1, prim$2, prim$3) {
                  prim.disconnect(prim$1, prim$2, prim$3);
                  return /* () */0;
                }), edge, graph);
          return /* () */0;
        }));
  var nowConnected = Belt_Set.reduce(edgesToConnect, emptyEdgeSet, (function (acc, edge) {
          var match = maybeApplyToGraph((function (prim, prim$1, prim$2, prim$3) {
                  prim.connect(prim$1, prim$2, prim$3);
                  return /* () */0;
                }), edge, graph);
          if (match !== undefined) {
            return Belt_Set.add(acc, match);
          } else {
            return acc;
          }
        }));
  return /* record */[
          /* nodes */graph[/* nodes */0],
          /* edges */graph[/* edges */1],
          /* actuallyConnectedEdges */nowConnected
        ];
}

export {
  EdgeComparator ,
  emptyEdgeSet ,
  emptyAudioGraph ,
  addNode ,
  removeAllEdgesInvolvingNode ,
  removeNode ,
  addEdge ,
  removeEdge ,
  maybeApplyToGraph ,
  updateConnections ,
  
}
/* EdgeComparator Not a pure module */
