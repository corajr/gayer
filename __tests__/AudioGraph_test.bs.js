// Generated by BUCKLESCRIPT VERSION 4.0.3, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/bs-jest/src/jest.js";
import * as Belt_Set from "bs-platform/lib/es6/belt_Set.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as AudioGraph$Gayer from "../src/AudioGraph.bs.js";

var mockAudioNode = function (id){return {'id': id, 'connect': (n) => 1, 'disconnect': (n) => 0 }};

var n1 = mockAudioNode("n1");

var n2 = mockAudioNode("n2");

var g1_000 = /* nodes */Belt_MapString.fromArray(/* array */[/* tuple */[
        "0",
        n1
      ]]);

var g1_001 = /* edges */AudioGraph$Gayer.emptyAudioGraph[/* edges */1];

var g1_002 = /* actuallyConnectedEdges */AudioGraph$Gayer.emptyAudioGraph[/* actuallyConnectedEdges */2];

var g1 = /* record */[
  g1_000,
  g1_001,
  g1_002
];

var g2_000 = /* nodes */Belt_MapString.fromArray(/* array */[
      /* tuple */[
        "0",
        n1
      ],
      /* tuple */[
        "1",
        n2
      ]
    ]);

var g2_001 = /* edges */AudioGraph$Gayer.emptyAudioGraph[/* edges */1];

var g2_002 = /* actuallyConnectedEdges */AudioGraph$Gayer.emptyAudioGraph[/* actuallyConnectedEdges */2];

var g2 = /* record */[
  g2_000,
  g2_001,
  g2_002
];

var edge = /* tuple */[
  "0",
  "1",
  0,
  0
];

var g2withEdge_000 = g2_000;

var g2withEdge_001 = /* edges */Belt_Set.add(AudioGraph$Gayer.emptyEdgeSet, edge);

var g2withEdge_002 = g2_002;

var g2withEdge = /* record */[
  g2withEdge_000,
  g2withEdge_001,
  g2withEdge_002
];

describe("addNode", (function () {
        Jest.test("adds to empty graph", (function () {
                return Jest.Expect[/* toEqual */12](g1, Jest.Expect[/* expect */0](AudioGraph$Gayer.addNode(/* tuple */[
                                    "0",
                                    n1
                                  ], AudioGraph$Gayer.emptyAudioGraph)));
              }));
        return Jest.test("adding same ID is idempotent", (function () {
                      return Jest.Expect[/* toEqual */12](g1, Jest.Expect[/* expect */0](AudioGraph$Gayer.addNode(/* tuple */[
                                          "0",
                                          n1
                                        ], g1)));
                    }));
      }));

describe("removeAllEdgesInvolvingNode", (function () {
        Jest.test("does nothing if node is absent", (function () {
                return Jest.Expect[/* toEqual */12](g2withEdge, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeAllEdgesInvolvingNode("2", g2withEdge)));
              }));
        Jest.test("removes the edges where node is source", (function () {
                return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeAllEdgesInvolvingNode("0", g2withEdge)));
              }));
        return Jest.test("removes the edges where node is target", (function () {
                      return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeAllEdgesInvolvingNode("1", g2withEdge)));
                    }));
      }));

describe("removeNode", (function () {
        Jest.test("does nothing if node is absent", (function () {
                return Jest.Expect[/* toEqual */12](AudioGraph$Gayer.emptyAudioGraph, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeNode("0", AudioGraph$Gayer.emptyAudioGraph)));
              }));
        return Jest.test("removes a node by ID", (function () {
                      return Jest.Expect[/* toEqual */12](AudioGraph$Gayer.emptyAudioGraph, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeNode("0", g1)));
                    }));
      }));

describe("addEdge", (function () {
        Jest.test("connects two nodes", (function () {
                return Jest.Expect[/* toEqual */12](g2withEdge, Jest.Expect[/* expect */0](AudioGraph$Gayer.addEdge(edge, g2)));
              }));
        return Jest.test("adding same edge is idempotent", (function () {
                      return Jest.Expect[/* toEqual */12](g2withEdge, Jest.Expect[/* expect */0](AudioGraph$Gayer.addEdge(edge, g2withEdge)));
                    }));
      }));

describe("removeEdge", (function () {
        Jest.test("does nothing if edge is absent", (function () {
                return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeEdge(edge, g2)));
              }));
        return Jest.test("removes an edge by source and target IDs", (function () {
                      return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.removeEdge(edge, g2withEdge)));
                    }));
      }));

describe("updateConnections", (function () {
        Jest.test("does nothing if no edges", (function () {
                return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.updateConnections(g2)));
              }));
        Jest.test("adds connections that are not yet made", (function () {
                return Jest.Expect[/* toEqual */12](/* record */[
                            g2withEdge_000,
                            g2withEdge_001,
                            /* actuallyConnectedEdges */Belt_Set.add(AudioGraph$Gayer.emptyEdgeSet, edge)
                          ], Jest.Expect[/* expect */0](AudioGraph$Gayer.updateConnections(g2withEdge)));
              }));
        return Jest.test("removes connections that are no longer desired", (function () {
                      return Jest.Expect[/* toEqual */12](g2, Jest.Expect[/* expect */0](AudioGraph$Gayer.updateConnections(/* record */[
                                          g2_000,
                                          g2_001,
                                          /* actuallyConnectedEdges */Belt_Set.add(AudioGraph$Gayer.emptyEdgeSet, edge)
                                        ])));
                    }));
      }));

var g = AudioGraph$Gayer.emptyAudioGraph;

export {
  g ,
  mockAudioNode ,
  n1 ,
  n2 ,
  g1 ,
  g2 ,
  edge ,
  g2withEdge ,
  
}
/* n1 Not a pure module */
